---
title: 泰勒展开及应用
pubDate: 2026-01-30
tags:
  - CS
author: Paul
---

## 泰勒展开

**核心思想**：任何平滑的函数 $f(x)$，在某一点 $a$ 附近，都可以用一个多项式来无限逼近。
$$f(x) \approx \underbrace{f(a)}_{\text{位置}} + \underbrace{f'(a)(x-a)}_{\text{坡度 (一阶)}} + \underbrace{\frac{1}{2}f''(a)(x-a)^2}_{\text{弯曲度 (二阶)}}$$

- **一阶展开**：是在这一点画一条**切线**。它只管现在的方向。
- **二阶展开**：是在这一点画一个**抛物线**。它不仅管方向，还管坡度变快还是变慢。

泰勒公式
$$f(x) = \sum_{n=0}^{\infty} \frac{f^{(n)}(x_0)}{n!}(x - x_0)^n$$

- **$f^{(n)}(x_0)$**：这是原函数在 $x_0$ 点的 $n$ 阶导数，代表了函数的“基因信息”。
- **$(x - x_0)^n$**：这是多项式的骨架。
- **$n!$**：这是为了抵消求导产生的系数，保证每一阶导数都能完美匹配。

## 应用

在高等数学和工程中，我们经常遇到<mark style="background: #FF5582A6;">“求不动”</mark>的函数（比如 $\sin(x) + \ln(x) = 0$）。

**应用逻辑**是：

1. 原函数 $f(x)$ 太复杂，我解不出来。
2. 我用泰勒展开把它变成**多项式**（直线或抛物线）。
3. 多项式方程非常容易解。
4. 解出来的结果就是原函数的一个**近似解**。

### 牛顿法

> https://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E6%B3%95

**牛顿法**（英语：Newton's method）又称为**牛顿-拉弗森方法**（英语：Newton-Raphson method），它是一种在实数域和复数域上近似求解方程的方法。（求根）

设我们要寻找方程 $f(x) = 0$ 的根，牛顿法的通用迭代公式为：

$$x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}$$

其中：

- **$x_n$**：当前迭代步的猜测值。
- **$x_{n+1}$**：经过修正后的下一个更好的猜测值。
- **$f(x_n)$**：函数在当前点的高度。
- **$f'(x_n)$**：函数在当前点的导数（切线斜率）。

步骤 A：泰勒级数展开（线性化）

假设我们现在处于 $x_n$ 点，我们想寻找一个位移 $h$，使得 $f(x_n + h) = 0$。

根据一阶泰勒展开，函数 $f(x)$ 在 $x_n$ 附近的近似值为：

$$f(x_n + h) \approx f(x_n) + f'(x_n) \cdot h$$

步骤 B：设定目标

我们希望找到那个能让函数值变为 $0$ 的 $h$。因此，我们令这个近似式等于 $0$：

$$f(x_n) + f'(x_n) \cdot h = 0$$

步骤 C：求解位移量 $h$

通过简单的代数变形，求出我们需要走多远：

$$f'(x_n) \cdot h = -f(x_n)$$

$$h = -\frac{f(x_n)}{f'(x_n)}$$

步骤 D：更新坐标

我们知道下一个点 $x_{n+1}$ 就是当前点 $x_n$ 加上位移 $h$：

$$x_{n+1} = x_n + h$$

$$x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}$$

#### 使用这个公式的“红线”

为了让这个公式收敛，数学上要求：

1. **一阶导数不能为零**：$f'(x_n) \neq 0$。如果导数为 0，意味着切线和 $x$ 轴平行，永远找不到交点，公式也会因为除以 0 而崩溃。
2. **函数需要足够平滑**：二阶导数 $f''(x)$ 最好不要在根附近剧烈波动，否则切线的预测会非常不准。
3. **初始值要选好**：通常需要 $x_0$ 落在根的一个“收敛半径”内。

### 例子

> 平方根函数：给定一个数 x，我们需要找到一个数 z 使得 z² 尽可能地接近 x。

分析，可知问题转为求根：
$$f(z) = z^2 - x$$

$$z_{n+1} = z_n - \frac{z^2-x}{2z_n}$$

```go
package main

import (
	"fmt"
	"math"
)

func Sqrt(x float64) float64 {
	// 1. 初始猜测值为 1.0
	z := 2.0

	// 为了观察变化，我们先记录上一次的值
	prevZ := 0.0

	fmt.Printf("开始计算 %v 的平方根：\n", x)

	// 2. 循环迭代
	for i := 1; i <= 10; i++ {
		prevZ = z
		// 牛顿法公式
		z -= (z*z - x) / (2 * z)

		fmt.Printf("第 %v 次迭代: z = %v\n", i, z)

		// 3. 改进：如果变化非常小，就提前退出
		// math.Abs 是求绝对值
		if math.Abs(z-prevZ) < 1e-10 {
			fmt.Printf("--- 在第 %v 次迭代时结果已稳定 ---\n", i)
			break
		}
	}
	return z
}

func main() {
	x := 2.0
	myRes := Sqrt(x)
	stdRes := math.Sqrt(x)

	fmt.Printf("\n最终结果: %v\n", myRes)
	fmt.Printf("标准库结果: %v\n", stdRes)
	fmt.Printf("误差: %v\n", math.Abs(myRes-stdRes))
}

```

结果如下

```bash
└─$ ./newton_method
开始计算 2 的平方根：
第 1 次迭代: z = 1.5
第 2 次迭代: z = 1.4166666666666667
第 3 次迭代: z = 1.4142156862745099
第 4 次迭代: z = 1.4142135623746899
第 5 次迭代: z = 1.4142135623730951
--- 在第 5 次迭代时结果已稳定 ---

最终结果: 1.4142135623730951
标准库结果: 1.4142135623730951
误差: 0
```
